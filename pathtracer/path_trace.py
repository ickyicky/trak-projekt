from .procedure import MainProcedure
from .ray import Ray
from .collision import get_collision
from .bitmap import color, Bitmap

import numpy as np


def path_trace(procedure: MainProcedure) -> Bitmap:
    """
    Main procedure:

    creates bitmap, renders each pixel from corresponding
    ray generated by camera.
    """
    bitmap = Bitmap(*procedure.scene.camera.resolution)
    for (x, y), ray in procedure.scene.camera.generate_initial_rays():
        bitmap[x, y] = trace_ray(procedure, ray)

    return bitmap


def trace_ray(
    procedure: MainProcedure,
    ray: Ray,
    depth: int = 0,
) -> np.array:
    """
    Trace ray
    """
    if depth > procedure.config.max_depth:
        return background(procedure, ray)

    hit = get_collision(ray, procedure)

    if hit is None:
        return background(procedure, ray)

    reflected_ray = Ray(
        origin=hit.coords,
        direction=sampler_in_hemisphere(hit.normal),
    )
    value = trace_ray(procedure, reflected_ray, depth + 1)
    return hit.hit_object.value + value * brdf


def sampler_in_hemisphere(
    normal: np.array,
) -> np.array:
    """
    Generates random direction for new
    ray
    """
    pass


def background(
    procedure: MainProcedure,
    ray: Ray,
) -> np.array:
    """
    Gets environment map value for the ray
    or returns black other way
    """
    return color(0, 0, 0)
