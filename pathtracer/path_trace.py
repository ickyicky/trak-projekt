from .procedure import MainProcedure
from .ray import Ray
from .collision import get_collision
from .bitmap import color, Bitmap
from .samplers import sampler_in_hemisphere

from multiprocessing import Pool
import numpy as np
import os
from typing import List, Tuple


PROCESS_PROCEDURE = None


def path_trace(procedure: MainProcedure) -> Bitmap:
    """
    Main procedure:

    creates bitmap, renders each pixel from corresponding
    ray generated by camera.
    """
    procedure.load_scene()
    procedure.scene.load_objects()
    procedure.scene.load_camera()
    bitmap = Bitmap(*procedure.scene.camera.resolution)

    pool = Pool(os.cpu_count())
    tasks = {}
    rays = procedure.scene.camera.generate_initial_rays()
    procedure.free_scene()  # for pickle

    for (x, y), ray in rays:
        tasks[(x, y)] = pool.apply_async(trace_ray_task, (ray, procedure))

    pool.close()
    pool.join()

    for x, y in tasks.keys():
        bitmap[y, x] = tasks[(x, y)].get()

    return bitmap


def trace_ray_task(
    ray: Ray,
    procedure_template: MainProcedure,
):
    """
    Task executed in Pool.
    """
    global PROCESS_PROCEDURE

    if PROCESS_PROCEDURE is None:
        PROCESS_PROCEDURE = procedure_template
        PROCESS_PROCEDURE.load_scene()
        PROCESS_PROCEDURE.scene.load_objects()
        PROCESS_PROCEDURE.scene.load_materials()

    samples = PROCESS_PROCEDURE.config.samples
    result = np.array([0.0, 0.0, 0.0])

    for sample in range(samples):
        result += trace_ray(PROCESS_PROCEDURE, ray)

    result = (result / samples * 255).astype("uint8")
    return result


def trace_ray(
    procedure: MainProcedure,
    ray: Ray,
    depth: int = 0,
) -> np.array:
    """
    Trace ray
    """
    if depth > procedure.config.max_depth:
        return background(procedure, ray)

    hit = get_collision(ray, procedure)

    if hit is None:
        return background(procedure, ray)

    new_ray = Ray(
        origin=hit.coords,
        direction=sampler_in_hemisphere(hit.normal),
    )

    probability = 1 / (2 * np.pi)

    hit_material = procedure.scene.get_material(hit.material_id)

    emmitance = hit_material.emmitance

    cos_theta = np.dot(new_ray.direction, hit.normal)

    brdf = hit_material.reflectance + hit_material.diffusion

    incoming = trace_ray(procedure, new_ray, depth + 1)
    if any(incoming):
        print(
            {
                "incoming": incoming,
                "brdf": brdf,
                "cos_theta": cos_theta,
                "probability": probability,
            }
        )

    # RENDER EQUATION
    return emmitance + (incoming * brdf * cos_theta / probability)


def background(
    procedure: MainProcedure,
    ray: Ray,
) -> np.array:
    """
    Gets environment map value for the ray
    or returns black other way
    """
    return color(0, 0, 0)
